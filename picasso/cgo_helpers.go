// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 13 May 2025 22:07:06 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package picasso

/*
#include "include/picasso.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *Context) Ref() *C.ps_context {
	if x == nil {
		return nil
	}
	return (*C.ps_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Context) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewContextRef converts the C object reference into a raw struct reference without wrapping.
func NewContextRef(ref unsafe.Pointer) *Context {
	return (*Context)(ref)
}

// NewContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewContext() *Context {
	return (*Context)(allocContextMemory(1))
}

// allocContextMemory allocates memory for type C.ps_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfContextValue = unsafe.Sizeof([1]C.ps_context{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Context) PassRef() *C.ps_context {
	if x == nil {
		x = (*Context)(allocContextMemory(1))
	}
	return (*C.ps_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Canvas) Ref() *C.ps_canvas {
	if x == nil {
		return nil
	}
	return (*C.ps_canvas)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Canvas) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCanvasRef converts the C object reference into a raw struct reference without wrapping.
func NewCanvasRef(ref unsafe.Pointer) *Canvas {
	return (*Canvas)(ref)
}

// NewCanvas allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCanvas() *Canvas {
	return (*Canvas)(allocCanvasMemory(1))
}

// allocCanvasMemory allocates memory for type C.ps_canvas in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCanvasMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCanvasValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCanvasValue = unsafe.Sizeof([1]C.ps_canvas{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Canvas) PassRef() *C.ps_canvas {
	if x == nil {
		x = (*Canvas)(allocCanvasMemory(1))
	}
	return (*C.ps_canvas)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Image) Ref() *C.ps_image {
	if x == nil {
		return nil
	}
	return (*C.ps_image)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Image) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewImageRef converts the C object reference into a raw struct reference without wrapping.
func NewImageRef(ref unsafe.Pointer) *Image {
	return (*Image)(ref)
}

// NewImage allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewImage() *Image {
	return (*Image)(allocImageMemory(1))
}

// allocImageMemory allocates memory for type C.ps_image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.ps_image{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Image) PassRef() *C.ps_image {
	if x == nil {
		x = (*Image)(allocImageMemory(1))
	}
	return (*C.ps_image)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Pattern) Ref() *C.ps_pattern {
	if x == nil {
		return nil
	}
	return (*C.ps_pattern)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Pattern) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPatternRef converts the C object reference into a raw struct reference without wrapping.
func NewPatternRef(ref unsafe.Pointer) *Pattern {
	return (*Pattern)(ref)
}

// NewPattern allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPattern() *Pattern {
	return (*Pattern)(allocPatternMemory(1))
}

// allocPatternMemory allocates memory for type C.ps_pattern in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPatternMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPatternValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPatternValue = unsafe.Sizeof([1]C.ps_pattern{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Pattern) PassRef() *C.ps_pattern {
	if x == nil {
		x = (*Pattern)(allocPatternMemory(1))
	}
	return (*C.ps_pattern)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Gradient) Ref() *C.ps_gradient {
	if x == nil {
		return nil
	}
	return (*C.ps_gradient)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Gradient) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewGradientRef converts the C object reference into a raw struct reference without wrapping.
func NewGradientRef(ref unsafe.Pointer) *Gradient {
	return (*Gradient)(ref)
}

// NewGradient allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewGradient() *Gradient {
	return (*Gradient)(allocGradientMemory(1))
}

// allocGradientMemory allocates memory for type C.ps_gradient in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGradientMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGradientValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGradientValue = unsafe.Sizeof([1]C.ps_gradient{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Gradient) PassRef() *C.ps_gradient {
	if x == nil {
		x = (*Gradient)(allocGradientMemory(1))
	}
	return (*C.ps_gradient)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Matrix) Ref() *C.ps_matrix {
	if x == nil {
		return nil
	}
	return (*C.ps_matrix)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Matrix) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMatrixRef converts the C object reference into a raw struct reference without wrapping.
func NewMatrixRef(ref unsafe.Pointer) *Matrix {
	return (*Matrix)(ref)
}

// NewMatrix allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMatrix() *Matrix {
	return (*Matrix)(allocMatrixMemory(1))
}

// allocMatrixMemory allocates memory for type C.ps_matrix in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMatrixMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMatrixValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMatrixValue = unsafe.Sizeof([1]C.ps_matrix{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Matrix) PassRef() *C.ps_matrix {
	if x == nil {
		x = (*Matrix)(allocMatrixMemory(1))
	}
	return (*C.ps_matrix)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Path) Ref() *C.ps_path {
	if x == nil {
		return nil
	}
	return (*C.ps_path)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Path) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPathRef converts the C object reference into a raw struct reference without wrapping.
func NewPathRef(ref unsafe.Pointer) *Path {
	return (*Path)(ref)
}

// NewPath allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPath() *Path {
	return (*Path)(allocPathMemory(1))
}

// allocPathMemory allocates memory for type C.ps_path in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPathMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPathValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPathValue = unsafe.Sizeof([1]C.ps_path{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Path) PassRef() *C.ps_path {
	if x == nil {
		x = (*Path)(allocPathMemory(1))
	}
	return (*C.ps_path)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Mask) Ref() *C.ps_mask {
	if x == nil {
		return nil
	}
	return (*C.ps_mask)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Mask) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMaskRef converts the C object reference into a raw struct reference without wrapping.
func NewMaskRef(ref unsafe.Pointer) *Mask {
	return (*Mask)(ref)
}

// NewMask allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMask() *Mask {
	return (*Mask)(allocMaskMemory(1))
}

// allocMaskMemory allocates memory for type C.ps_mask in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMaskMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMaskValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMaskValue = unsafe.Sizeof([1]C.ps_mask{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Mask) PassRef() *C.ps_mask {
	if x == nil {
		x = (*Mask)(allocMaskMemory(1))
	}
	return (*C.ps_mask)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Font) Ref() *C.ps_font {
	if x == nil {
		return nil
	}
	return (*C.ps_font)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Font) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFontRef converts the C object reference into a raw struct reference without wrapping.
func NewFontRef(ref unsafe.Pointer) *Font {
	return (*Font)(ref)
}

// NewFont allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFont() *Font {
	return (*Font)(allocFontMemory(1))
}

// allocFontMemory allocates memory for type C.ps_font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFontValue = unsafe.Sizeof([1]C.ps_font{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Font) PassRef() *C.ps_font {
	if x == nil {
		x = (*Font)(allocFontMemory(1))
	}
	return (*C.ps_font)(unsafe.Pointer(x))
}

// allocGlyphMemory allocates memory for type C.ps_glyph in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGlyphMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGlyphValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGlyphValue = unsafe.Sizeof([1]C.ps_glyph{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Glyph) Ref() *C.ps_glyph {
	if x == nil {
		return nil
	}
	return x.ref84be1ec8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Glyph) Free() {
	if x != nil && x.allocs84be1ec8 != nil {
		x.allocs84be1ec8.(*cgoAllocMap).Free()
		x.ref84be1ec8 = nil
	}
}

// NewGlyphRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGlyphRef(ref unsafe.Pointer) *Glyph {
	if ref == nil {
		return nil
	}
	obj := new(Glyph)
	obj.ref84be1ec8 = (*C.ps_glyph)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Glyph) PassRef() (*C.ps_glyph, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref84be1ec8 != nil {
		return x.ref84be1ec8, nil
	}
	mem84be1ec8 := allocGlyphMemory(1)
	ref84be1ec8 := (*C.ps_glyph)(mem84be1ec8)
	allocs84be1ec8 := new(cgoAllocMap)
	allocs84be1ec8.Add(mem84be1ec8)

	var cglyph_allocs *cgoAllocMap
	ref84be1ec8.glyph, cglyph_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Glyph)), cgoAllocsUnknown
	allocs84be1ec8.Borrow(cglyph_allocs)

	x.ref84be1ec8 = ref84be1ec8
	x.allocs84be1ec8 = allocs84be1ec8
	return ref84be1ec8, allocs84be1ec8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Glyph) PassValue() (C.ps_glyph, *cgoAllocMap) {
	if x.ref84be1ec8 != nil {
		return *x.ref84be1ec8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Glyph) Deref() {
	if x.ref84be1ec8 == nil {
		return
	}
	x.Glyph = (unsafe.Pointer)(unsafe.Pointer(x.ref84be1ec8.glyph))
}

// allocSizeMemory allocates memory for type C.ps_size in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSizeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSizeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSizeValue = unsafe.Sizeof([1]C.ps_size{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Size) Ref() *C.ps_size {
	if x == nil {
		return nil
	}
	return x.ref9075d356
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Size) Free() {
	if x != nil && x.allocs9075d356 != nil {
		x.allocs9075d356.(*cgoAllocMap).Free()
		x.ref9075d356 = nil
	}
}

// NewSizeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSizeRef(ref unsafe.Pointer) *Size {
	if ref == nil {
		return nil
	}
	obj := new(Size)
	obj.ref9075d356 = (*C.ps_size)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Size) PassRef() (*C.ps_size, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9075d356 != nil {
		return x.ref9075d356, nil
	}
	mem9075d356 := allocSizeMemory(1)
	ref9075d356 := (*C.ps_size)(mem9075d356)
	allocs9075d356 := new(cgoAllocMap)
	allocs9075d356.Add(mem9075d356)

	var cw_allocs *cgoAllocMap
	ref9075d356.w, cw_allocs = (C.float)(x.W), cgoAllocsUnknown
	allocs9075d356.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref9075d356.h, ch_allocs = (C.float)(x.H), cgoAllocsUnknown
	allocs9075d356.Borrow(ch_allocs)

	x.ref9075d356 = ref9075d356
	x.allocs9075d356 = allocs9075d356
	return ref9075d356, allocs9075d356

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Size) PassValue() (C.ps_size, *cgoAllocMap) {
	if x.ref9075d356 != nil {
		return *x.ref9075d356, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Size) Deref() {
	if x.ref9075d356 == nil {
		return
	}
	x.W = (float32)(x.ref9075d356.w)
	x.H = (float32)(x.ref9075d356.h)
}

// allocRectMemory allocates memory for type C.ps_rect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRectValue = unsafe.Sizeof([1]C.ps_rect{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rect) Ref() *C.ps_rect {
	if x == nil {
		return nil
	}
	return x.refd063c4bd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Rect) Free() {
	if x != nil && x.allocsd063c4bd != nil {
		x.allocsd063c4bd.(*cgoAllocMap).Free()
		x.refd063c4bd = nil
	}
}

// NewRectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectRef(ref unsafe.Pointer) *Rect {
	if ref == nil {
		return nil
	}
	obj := new(Rect)
	obj.refd063c4bd = (*C.ps_rect)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rect) PassRef() (*C.ps_rect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd063c4bd != nil {
		return x.refd063c4bd, nil
	}
	memd063c4bd := allocRectMemory(1)
	refd063c4bd := (*C.ps_rect)(memd063c4bd)
	allocsd063c4bd := new(cgoAllocMap)
	allocsd063c4bd.Add(memd063c4bd)

	var cx_allocs *cgoAllocMap
	refd063c4bd.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocsd063c4bd.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refd063c4bd.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocsd063c4bd.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	refd063c4bd.w, cw_allocs = (C.float)(x.W), cgoAllocsUnknown
	allocsd063c4bd.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	refd063c4bd.h, ch_allocs = (C.float)(x.H), cgoAllocsUnknown
	allocsd063c4bd.Borrow(ch_allocs)

	x.refd063c4bd = refd063c4bd
	x.allocsd063c4bd = allocsd063c4bd
	return refd063c4bd, allocsd063c4bd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rect) PassValue() (C.ps_rect, *cgoAllocMap) {
	if x.refd063c4bd != nil {
		return *x.refd063c4bd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Rect) Deref() {
	if x.refd063c4bd == nil {
		return
	}
	x.X = (float32)(x.refd063c4bd.x)
	x.Y = (float32)(x.refd063c4bd.y)
	x.W = (float32)(x.refd063c4bd.w)
	x.H = (float32)(x.refd063c4bd.h)
}

// allocPointMemory allocates memory for type C.ps_point in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPointValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPointValue = unsafe.Sizeof([1]C.ps_point{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Point) Ref() *C.ps_point {
	if x == nil {
		return nil
	}
	return x.ref98ad3a54
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Point) Free() {
	if x != nil && x.allocs98ad3a54 != nil {
		x.allocs98ad3a54.(*cgoAllocMap).Free()
		x.ref98ad3a54 = nil
	}
}

// NewPointRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPointRef(ref unsafe.Pointer) *Point {
	if ref == nil {
		return nil
	}
	obj := new(Point)
	obj.ref98ad3a54 = (*C.ps_point)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Point) PassRef() (*C.ps_point, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref98ad3a54 != nil {
		return x.ref98ad3a54, nil
	}
	mem98ad3a54 := allocPointMemory(1)
	ref98ad3a54 := (*C.ps_point)(mem98ad3a54)
	allocs98ad3a54 := new(cgoAllocMap)
	allocs98ad3a54.Add(mem98ad3a54)

	var cx_allocs *cgoAllocMap
	ref98ad3a54.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs98ad3a54.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref98ad3a54.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs98ad3a54.Borrow(cy_allocs)

	x.ref98ad3a54 = ref98ad3a54
	x.allocs98ad3a54 = allocs98ad3a54
	return ref98ad3a54, allocs98ad3a54

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Point) PassValue() (C.ps_point, *cgoAllocMap) {
	if x.ref98ad3a54 != nil {
		return *x.ref98ad3a54, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Point) Deref() {
	if x.ref98ad3a54 == nil {
		return
	}
	x.X = (float32)(x.ref98ad3a54.x)
	x.Y = (float32)(x.ref98ad3a54.y)
}

// allocColorMemory allocates memory for type C.ps_color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfColorValue = unsafe.Sizeof([1]C.ps_color{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Color) Ref() *C.ps_color {
	if x == nil {
		return nil
	}
	return x.ref495e8199
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Color) Free() {
	if x != nil && x.allocs495e8199 != nil {
		x.allocs495e8199.(*cgoAllocMap).Free()
		x.ref495e8199 = nil
	}
}

// NewColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewColorRef(ref unsafe.Pointer) *Color {
	if ref == nil {
		return nil
	}
	obj := new(Color)
	obj.ref495e8199 = (*C.ps_color)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Color) PassRef() (*C.ps_color, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref495e8199 != nil {
		return x.ref495e8199, nil
	}
	mem495e8199 := allocColorMemory(1)
	ref495e8199 := (*C.ps_color)(mem495e8199)
	allocs495e8199 := new(cgoAllocMap)
	allocs495e8199.Add(mem495e8199)

	var cr_allocs *cgoAllocMap
	ref495e8199.r, cr_allocs = (C.float)(x.R), cgoAllocsUnknown
	allocs495e8199.Borrow(cr_allocs)

	var cg_allocs *cgoAllocMap
	ref495e8199.g, cg_allocs = (C.float)(x.G), cgoAllocsUnknown
	allocs495e8199.Borrow(cg_allocs)

	var cb_allocs *cgoAllocMap
	ref495e8199.b, cb_allocs = (C.float)(x.B), cgoAllocsUnknown
	allocs495e8199.Borrow(cb_allocs)

	var ca_allocs *cgoAllocMap
	ref495e8199.a, ca_allocs = (C.float)(x.A), cgoAllocsUnknown
	allocs495e8199.Borrow(ca_allocs)

	x.ref495e8199 = ref495e8199
	x.allocs495e8199 = allocs495e8199
	return ref495e8199, allocs495e8199

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Color) PassValue() (C.ps_color, *cgoAllocMap) {
	if x.ref495e8199 != nil {
		return *x.ref495e8199, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Color) Deref() {
	if x.ref495e8199 == nil {
		return
	}
	x.R = (float32)(x.ref495e8199.r)
	x.G = (float32)(x.ref495e8199.g)
	x.B = (float32)(x.ref495e8199.b)
	x.A = (float32)(x.ref495e8199.a)
}

// allocFontInfoMemory allocates memory for type C.ps_font_info in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFontInfoValue = unsafe.Sizeof([1]C.ps_font_info{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FontInfo) Ref() *C.ps_font_info {
	if x == nil {
		return nil
	}
	return x.ref4d462aab
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FontInfo) Free() {
	if x != nil && x.allocs4d462aab != nil {
		x.allocs4d462aab.(*cgoAllocMap).Free()
		x.ref4d462aab = nil
	}
}

// NewFontInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFontInfoRef(ref unsafe.Pointer) *FontInfo {
	if ref == nil {
		return nil
	}
	obj := new(FontInfo)
	obj.ref4d462aab = (*C.ps_font_info)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FontInfo) PassRef() (*C.ps_font_info, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4d462aab != nil {
		return x.ref4d462aab, nil
	}
	mem4d462aab := allocFontInfoMemory(1)
	ref4d462aab := (*C.ps_font_info)(mem4d462aab)
	allocs4d462aab := new(cgoAllocMap)
	allocs4d462aab.Add(mem4d462aab)

	var csize_allocs *cgoAllocMap
	ref4d462aab.size, csize_allocs = (C.float)(x.Size), cgoAllocsUnknown
	allocs4d462aab.Borrow(csize_allocs)

	var cascent_allocs *cgoAllocMap
	ref4d462aab.ascent, cascent_allocs = (C.float)(x.Ascent), cgoAllocsUnknown
	allocs4d462aab.Borrow(cascent_allocs)

	var cdescent_allocs *cgoAllocMap
	ref4d462aab.descent, cdescent_allocs = (C.float)(x.Descent), cgoAllocsUnknown
	allocs4d462aab.Borrow(cdescent_allocs)

	var cleading_allocs *cgoAllocMap
	ref4d462aab.leading, cleading_allocs = (C.float)(x.Leading), cgoAllocsUnknown
	allocs4d462aab.Borrow(cleading_allocs)

	var cunitsEM_allocs *cgoAllocMap
	ref4d462aab.unitsEM, cunitsEM_allocs = (C.uint32_t)(x.Unitsem), cgoAllocsUnknown
	allocs4d462aab.Borrow(cunitsEM_allocs)

	x.ref4d462aab = ref4d462aab
	x.allocs4d462aab = allocs4d462aab
	return ref4d462aab, allocs4d462aab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FontInfo) PassValue() (C.ps_font_info, *cgoAllocMap) {
	if x.ref4d462aab != nil {
		return *x.ref4d462aab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FontInfo) Deref() {
	if x.ref4d462aab == nil {
		return
	}
	x.Size = (float32)(x.ref4d462aab.size)
	x.Ascent = (float32)(x.ref4d462aab.ascent)
	x.Descent = (float32)(x.ref4d462aab.descent)
	x.Leading = (float32)(x.ref4d462aab.leading)
	x.Unitsem = (uint32)(x.ref4d462aab.unitsEM)
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// copyPCanvasBytes copies the data from Go slice as *C.ps_canvas.
func copyPCanvasBytes(slice *sliceHeader) (*C.ps_canvas, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCanvasValue) * slice.Len,
		Cap:  int(sizeOfCanvasValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.ps_canvas)(mem0), allocs
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSPoint transforms a sliced Go data structure into plain C format.
func unpackArgSPoint(x []Point) (unpacked *C.ps_point, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPointMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.ps_point)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.ps_point)(h.Data)
	return
}

// packSPoint reads sliced Go data structure out from plain C format.
func packSPoint(v []Point, ptr0 *C.ps_point) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPointValue]C.ps_point)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPointRef(unsafe.Pointer(&ptr1))
	}
}

// copyPMatrixBytes copies the data from Go slice as *C.ps_matrix.
func copyPMatrixBytes(slice *sliceHeader) (*C.ps_matrix, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfMatrixValue) * slice.Len,
		Cap:  int(sizeOfMatrixValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.ps_matrix)(mem0), allocs
}

// unpackArgSColor transforms a sliced Go data structure into plain C format.
func unpackArgSColor(x []Color) (unpacked *C.ps_color, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocColorMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.ps_color)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.ps_color)(h.Data)
	return
}

// packSColor reads sliced Go data structure out from plain C format.
func packSColor(v []Color, ptr0 *C.ps_color) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfColorValue]C.ps_color)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewColorRef(unsafe.Pointer(&ptr1))
	}
}

// copyPFloatBytes copies the data from Go slice as *C.float.
func copyPFloatBytes(slice *sliceHeader) (*C.float, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfFloatValue) * slice.Len,
		Cap:  int(sizeOfFloatValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.float)(mem0), allocs
}

// allocFloatMemory allocates memory for type C.float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFloatValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFloatValue = unsafe.Sizeof([1]C.float{})

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	str = safeString(str)
	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// unpackArgSSize transforms a sliced Go data structure into plain C format.
func unpackArgSSize(x []Size) (unpacked *C.ps_size, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSizeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.ps_size)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.ps_size)(h.Data)
	return
}

// packSSize reads sliced Go data structure out from plain C format.
func packSSize(v []Size, ptr0 *C.ps_size) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSizeValue]C.ps_size)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSizeRef(unsafe.Pointer(&ptr1))
	}
}

// copyPUchar16Bytes copies the data from Go slice as *C.ps_uchar16.
func copyPUchar16Bytes(slice *sliceHeader) (*C.ps_uchar16, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUchar16Value) * slice.Len,
		Cap:  int(sizeOfUchar16Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.ps_uchar16)(mem0), allocs
}

// allocUchar16Memory allocates memory for type C.ps_uchar16 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUchar16Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUchar16Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUchar16Value = unsafe.Sizeof([1]C.ps_uchar16{})

// unpackArgSGlyph transforms a sliced Go data structure into plain C format.
func unpackArgSGlyph(x []Glyph) (unpacked *C.ps_glyph, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocGlyphMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.ps_glyph)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.ps_glyph)(h.Data)
	return
}

// packSGlyph reads sliced Go data structure out from plain C format.
func packSGlyph(v []Glyph, ptr0 *C.ps_glyph) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfGlyphValue]C.ps_glyph)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewGlyphRef(unsafe.Pointer(&ptr1))
	}
}

// copyPPathBytes copies the data from Go slice as *C.ps_path.
func copyPPathBytes(slice *sliceHeader) (*C.ps_path, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPathValue) * slice.Len,
		Cap:  int(sizeOfPathValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.ps_path)(mem0), allocs
}
